
You are a Senior Kotlin programmer with experience in the Android framework and a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## Kotlin General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using any.
  - Create necessary types.
- Don't leave blank lines within a function.

### KISS Principle (Keep It Simple, Stupid)

**Philosophy**: Simplicity should be a key goal in design. Most systems work best if they are kept simple rather than made complicated.

**Core Guidelines**:
- Write code that is **easy to read and understand**
- Prefer **simple solutions** over clever ones
- Break complex problems into **smaller, manageable pieces**
- Each function/class should do **one thing well**
- Avoid **premature optimization**
- Remove **unnecessary abstractions**
- Eliminate **redundant code**

**Practical Applications**:

1. **Function Complexity**:
   - Keep functions under 20 lines when possible
   - Maximum 2-3 levels of nesting
   - If a function is hard to name, it probably does too much
   - Extract complex logic into well-named helper functions

2. **Code Structure**:
   ```kotlin
   // ‚ùå COMPLEX: Too many responsibilities
   fun processUserDataAndSendEmailAndLogActivity(user: User) {
       validateUser(user)
       val data = transformData(user)
       sendEmail(user.email, data)
       logActivity(user.id, "processed")
       updateDatabase(user)
   }
   
   // ‚úÖ SIMPLE: Single responsibility per function
   fun processUser(user: User) {
       val validatedUser = validateUser(user)
       val processedData = transformUserData(validatedUser)
       saveProcessedData(processedData)
   }
   
   private fun validateUser(user: User): User { /* ... */ }
   private fun transformUserData(user: User): ProcessedData { /* ... */ }
   private fun saveProcessedData(data: ProcessedData) { /* ... */ }
   ```

3. **Reduce Nesting**:
   ```kotlin
   // ‚ùå COMPLEX: Deep nesting (4 levels)
   fun funName(article: Article?): Result {
       if (article != null) {
           if (article.isValid()) {
               if (article.hasContent()) {
                   if (article.content.length > 0) {
                       return Result.Success(article)
                   }
               }
           }
       }
       return Result.Error("Invalid article")
   }
   
   // ‚úÖ SIMPLE: Early returns (1-2 levels)
   fun funName(article: Article?): Result {
       if (article == null) return Result.Error("Article is null")
       if (!article.isValid()) return Result.Error("Article is invalid")
       if (!article.hasContent()) return Result.Error("No content")
       if (article.content.isEmpty()) return Result.Error("Empty content")
       
       return Result.Success(article)
   }
   ```

4. **Use Kotlin Idioms**:
   ```kotlin
   // ‚ùå COMPLEX: Verbose null checks
   if (user != null && user.email != null && user.email.isNotBlank()) {
       sendEmail(user.email)
   }
   
   // ‚úÖ SIMPLE: Safe calls and let
   user?.email?.takeIf { it.isNotBlank() }?.let { sendEmail(it) }
   ```

5. **Prefer Composition over Complex Inheritance**:
   ```kotlin
   // ‚ùå COMPLEX: Deep inheritance hierarchy
   open class BaseRepository
   abstract class CachedRepository : BaseRepository()
   abstract class NetworkRepository : CachedRepository()
   class NewsRepository : NetworkRepository()
   
   // ‚úÖ SIMPLE: Composition with clear responsibilities
   class NewsRepository(
       private val networkSource: NetworkDataSource,
       private val cacheSource: CacheDataSource
   )
   ```

6. **Small, Focused Classes**:
   - One primary responsibility per class
   - Less than 200 lines of code
   - Less than 10 public methods
   - If you need extensive comments to explain what a class does, simplify it

7. **Avoid Over-Engineering**:
   - Don't create abstractions for future needs that may never come
   - Don't implement design patterns just because they exist
   - Start simple, refactor when complexity is actually needed
   - YAGNI (You Aren't Gonna Need It)

8. **Clear Naming over Comments**:
   ```kotlin
   // ‚ùå COMPLEX: Needs comment to understand
   fun proc(u: User, f: Int): Boolean {
       // Check if user is active and flag is set to 1
       return u.status == "active" && f == 1
   }
   
   // ‚úÖ SIMPLE: Self-documenting code
   fun isUserActiveWithFlag(user: User, flag: Int): Boolean {
       return user.isActive() && flag == ACTIVE_FLAG
   }
   ```

9. **Extension Functions for Clarity**:
   ```kotlin
   // ‚ùå COMPLEX: Repeated logic scattered
   if (text != null && text.isNotEmpty() && text.length > 100) { /* ... */ }
   
   // ‚úÖ SIMPLE: Reusable extension
   fun String?.isLongText(): Boolean = 
       this != null && isNotEmpty() && length > 100
   
   if (text.isLongText()) { /* ... */ }
   ```

10. **Remove Dead Code and Logs**:
    - Delete commented-out code
    - Remove unused imports
    - Remove debug logs in production code
    - Use version control instead of keeping old code "just in case"

**When to Apply KISS**:
- ‚úÖ When writing new code
- ‚úÖ When refactoring existing code
- ‚úÖ When reviewing pull requests
- ‚úÖ When a function exceeds 20 lines
- ‚úÖ When nesting exceeds 2-3 levels
- ‚úÖ When you struggle to name something clearly
- ‚úÖ When adding "utils" or "helper" classes (often a code smell)

**Red Flags (Code is too complex)**:
- üö© Functions longer than 30 lines
- üö© More than 3 levels of nesting
- üö© Classes with more than 10 methods
- üö© Need extensive comments to explain logic
- üö© Multiple responsibilities in one place
- üö© Clever code that's hard to read
- üö© Deep inheritance hierarchies (3+ levels)

**Remember**: 
> "Any fool can write code that a computer can understand. Good programmers write code that humans can understand." - Martin Fowler

> "Simplicity is the ultimate sophistication." - Leonardo da Vinci

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use underscores_case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions

- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data

- Use data classes for data.
- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as val for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

### Exceptions

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

### Testing

- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
  - Use test doubles to simulate dependencies.
    - Except for third-party dependencies that are not expensive to execute.
- Write acceptance tests for each module.
  - Follow the Given-When-Then convention.

## Specific to Android

### Architecture Principles

#### Clean Architecture Structure
Organize code into three main layers:

**Domain Layer** (`domain/`):
- Contains business logic and entities
- Models: Pure Kotlin data classes without Android/Framework dependencies
- Repository Interfaces: Define contracts for data operations
- Use Cases: Encapsulate single business operations
  - Use `operator fun invoke()` for clean invocation
  - Each UseCase should have a single responsibility
  - Inject repositories via constructor

**Data Layer** (`data/`):
- API: Retrofit services and DTOs (Data Transfer Objects)
- DTOs: Separate models for API responses with `@SerializedName` annotations
- Mappers: Convert DTOs to Domain models
  - Create mapper classes (not objects) for dependency injection
  - One mapper per data source (e.g., `NewsMapper`, `UserMapper`)
- Repository Implementations: Concrete implementations of domain interfaces
  - Name pattern: `XxxRepositoryImpl` implements `IXxxRepository`
  - Inject mappers and API services via constructor

**Presentation Layer** (`presentation/`):
- ViewModels: Manage UI state using StateFlow
- UI State: Sealed classes for representing different states
- Screens: Jetpack Compose composables
- Navigation: Navigation Compose setup

#### Dependency Injection with Koin

**Module Organization** (`di/`):
Create separate modules for each layer:

- `NetworkModule`: Retrofit services and API instances
```kotlin
val networkModule = module {
    single<XxxApiService> { RetrofitClient.xxxApiService }
}
```

- `DataModule`: Mappers and Repository implementations
```kotlin
val dataModule = module {
    single { XxxMapper() }
    single<IXxxRepository> { 
        XxxRepositoryImpl(
            apiService = get(),
            mapper = get()
        ) 
    }
}
```

- `DomainModule`: Use Cases
```kotlin
val domainModule = module {
    factory { XxxUseCase(repository = get()) }
}
```

- `PresentationModule`: ViewModels
```kotlin
val presentationModule = module {
    viewModel { XxxViewModel(useCase = get()) }
}
```

- `AppModule`: Aggregate all modules
```kotlin
val appModules = listOf(
    networkModule,
    dataModule,
    domainModule,
    presentationModule
)
```

**Application Setup**:
- Create custom `Application` class
- Initialize Koin in `onCreate()`
- Register application in `AndroidManifest.xml`

**ViewModel Injection**:
- Use `koinViewModel()` in composables
- Never create ViewModels manually with factories

#### Repository Pattern

- Always create interface in `domain/repository/`
  - Name pattern: `IXxxRepository`
  - Define suspend functions returning `Result<T>`
  
- Create implementation in `data/repository/`
  - Name pattern: `XxxRepositoryImpl`
  - Inject dependencies (API services, mappers) via constructor
  - Handle errors and return `Result.success()` or `Result.failure()`
  - Add logging for debugging

#### Use Cases (Interactors)

- Create in `domain/usecase/`
- Name pattern: `VerbNounUseCase` (e.g., `SearchNewsUseCase`, `GetUserProfileUseCase`)
- Inject repositories via constructor
- Implement `suspend operator fun invoke()` for clean invocation
- Keep business logic here, not in ViewModels
- Return `Result<T>` for error handling
- **Apply KISS principle**: Break complex use cases into small, focused functions
  - Each function should do one thing well
  - Use descriptive names that explain intent
  - Keep functions under 20 lines
  - Extract complex logic into private helper functions
  - Avoid deep nesting (max 2-3 levels)

#### State Management

- Use StateFlow for UI state in ViewModels
- Create sealed classes for different UI states:
```kotlin
sealed class XxxUiState {
    data object Initial : XxxUiState()
    data object Loading : XxxUiState()
    data class Success(val data: T) : XxxUiState()
    data class Error(val message: String) : XxxUiState()
}
```
- Use `viewModelScope.launch` for coroutines
- Expose StateFlow as immutable with `asStateFlow()`

#### Jetpack Compose UI

- Use Jetpack Compose for UI (not XML/fragments)
- Follow Material Design 3 guidelines
- Use `MaterialTheme.colorScheme` for colors
- Implement Navigation Compose for screen navigation
- Use Coil for image loading
- Keep composables small and focused
- Extract reusable UI components

#### Networking

- Use Retrofit + OkHttp for API calls
- Create separate service interfaces for each API
- Use DTOs with `@SerializedName` for JSON mapping
- Add logging interceptor for debugging
- Handle network errors gracefully
- Use `suspend` functions for API calls
- Combine multiple API calls with `coroutineScope` and `async`/`await`

#### Error Handling

- Use `Result<T>` for operations that can fail
- Add try-catch blocks in repositories and use cases
- Provide meaningful error messages to users
- Handle empty states appropriately
- **Keep error handling simple**:
  - Return original/default values on error in non-critical operations
  - Use silent fallbacks when appropriate (e.g., return cached data)
  - Avoid excessive logging in production code
  - Don't over-complicate error recovery logic

### Testing

- Write unit tests for Use Cases
- Mock repositories using test doubles
- Test ViewModels with StateFlow assertions
- Use integration tests for repository implementations
- Follow Arrange-Act-Assert convention

### Additional Guidelines

- Use coroutines + ViewModelScope.launch for async operations
- Combine flows with `combine()` or `zip()` from Kotlin Flow
- Add basic error handling (display Snackbar/Toast)
- Create responsive layouts for tablets and phones
- Support light/dark theme automatically with Material 3
- Always add internet permission in AndroidManifest when using network

## Design System Module

### Overview

The project has a dedicated `design-system` module that contains all reusable UI components, design tokens, and design guidelines. This ensures consistency, maintainability, and reusability across the application.


### Design Tokens (Dimens.kt)

**Purpose**: Centralize all dimension values (dp) to ensure visual consistency across the app.

**Guidelines**:
- **Never hardcode dp values** in components or screens
- Always reference values from `Dimens` object
- Use semantic naming that describes the purpose, not the value
- Organize by category (spacing, corner radius, card dimensions, icons, buttons, elevation)

**Example Usage**:

// ‚úÖ CORRECT
Text(
    text = "Hello",
    modifier = Modifier.padding(Dimens.spacingDefault)
)

// ‚ùå WRONG
Text(
    text = "Hello",
    modifier = Modifier.padding(16.dp)
)
```

**Available Token Categories**:
- **Spacing**: `spacingXxs` (2dp), `spacingXs` (4dp), `spacingSmall` (8dp), `spacingMedium` (12dp), `spacingDefault` (16dp), `spacingLarge` (24dp), `spacingXl` (32dp), `spacingXxl` (48dp)
- **Corner Radius**: `cornerRadiusSmall` (4dp), `cornerRadiusMedium` (8dp), `cornerRadiusDefault` (12dp), `cornerRadiusLarge` (16dp), `cornerRadiusXl` (24dp)
- **Card Dimensions**: `newsCardLargeImageHeight`, `newsCardSmallImageSize`, `thumbnailSize`
- **Icon Sizes**: `iconSizeXs`, `iconSizeSmall`, `iconSizeMedium`, `iconSizeDefault`, `iconSizeLarge`, `iconSizeXl`
- **Button Dimensions**: `buttonHeightMin`, `buttonHeightDefault`, `buttonHeightLarge`
- **Elevation**: `elevationNone`, `elevationLow`, `elevationMedium`, `elevationHigh`, `elevationXl`

### Reusable Components

**Location**: `design-system/src/main/java/com/app4funbr/design_system/components/`

**Guidelines**:
- Components should be **generic and reusable** across different screens
- Use **interfaces** to decouple components from domain models (e.g., `INewsCardData`)
- All components must have `@Preview` annotations for easy visualization
- Use **Material Design 3** guidelines
- Always use **Dimens** tokens for spacing, sizing, and corner radius
- Components should be **stateless** and controlled by parent
- Document component purpose and parameters with KDoc

**Component Structure**:
```kotlin
/**
 * Brief description of the component.
 * 
 * Detailed explanation of what it displays or does.
 * 
 * @param data Data interface (e.g., INewsCardData)
 * @param onClick Callback for click actions
 * @param modifier Optional modifiers
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MyComponent(
    data: IMyComponentData,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    // Implementation using Dimens tokens
}

// Preview with mock data
@Preview(showBackground = true, name = "My Component")
@Composable
fun PreviewMyComponent() {
    MaterialTheme {
        MyComponent(
            data = PreviewData(...),
            onClick = {}
        )
    }
}
```

### When to Create a New Component

Move UI code to `design-system` when:
1. **Component is reused** in 2+ screens
2. **Component is generic** and not tied to specific business logic
3. **Component is self-contained** and has a clear responsibility
4. **Component follows Material Design 3** patterns

### When NOT to Move to Design System

Keep in app module when:
1. Component is **screen-specific** or contains business logic
2. Component is **tightly coupled** to app-specific data models
3. Component is a **composition of design-system components** (e.g., entire screen layouts)

### Data Interfaces

**Purpose**: Decouple design-system components from app-specific domain models.

**Pattern**:
```kotlin
// In design-system module
interface INewsCardData {
    val title: String
    val description: String?
    val imageUrl: String?
    val source: String
}

// In app module
data class NewsArticle(
    override val title: String,
    override val description: String?,
    override val imageUrl: String?,
    val url: String,  // App-specific field
    override val source: String,
    val publishedAt: String?,  // App-specific field
    val content: String?  // App-specific field
) : INewsCardData
```

**Benefits**:
- Components don't depend on concrete app models
- Easy to create mock data for previews
- Facilitates testing and reusability

### Adding New Dimensions

When adding new dp values:
1. **Check if similar value exists** in `Dimens.kt`
2. **Add to appropriate category** with semantic name
3. **Document the purpose** with KDoc comment
4. **Update this guide** if adding a new category

**Example**:
```kotlin
object Dimens {
    // ... existing values ...
    
    // ===================== MY NEW CATEGORY =====================
    
    /** Description of what this dimension is for: XXdp */
    val myNewDimension: Dp = XX.dp
}
```

### Best Practices

1. **Always import Dimens**: `import com.app4funbr.design_system.tokens.Dimens`
2. **Use semantic names**: Choose the dimension that matches the purpose, not the exact value
3. **Keep components simple**: One component = one responsibility
4. **Add comprehensive previews**: Include different states (with/without data, error states, etc.)
5. **Document everything**: Use KDoc for public components and parameters
6. **Follow Material 3**: Use `MaterialTheme.colorScheme`, `MaterialTheme.typography`
7. **Make components themeable**: Avoid hardcoded colors, use theme colors
8. **Support dark mode**: Test components in both light and dark themes

### Module Dependencies

The `design-system` module should have minimal dependencies:
- ‚úÖ Jetpack Compose
- ‚úÖ Material 3
- ‚úÖ Coil (for image loading)
- ‚ùå NO app-specific dependencies
- ‚ùå NO business logic dependencies
- ‚ùå NO ViewModels or state management

### Usage in App Module

```kotlin
// build.gradle.kts
dependencies {
    implementation(project(":design-system"))
    // ... other dependencies
}

// In Composable
import com.app4funbr.design_system.components.news.LargeNewsCard
import com.app4funbr.design_system.tokens.Dimens

@Composable
fun MyScreen() {
    Column(
        modifier = Modifier.padding(Dimens.spacingDefault)
    ) {
        LargeNewsCard(
            data = myNewsArticle,
            onClick = { /* handle click */ }
        )
    }
}
```

## KISS in Practice: UseCase Refactoring Example

### Before (Complex - 188 lines, deep nesting, multiple responsibilities)

```kotlin
class ProcessBatchArticlesUseCase(private val geminiService: GeminiService) {
    
    suspend operator fun invoke(articles: List<NewsArticle>): List<NewsArticle> {
        return withContext(Dispatchers.IO) {
            try {
                Log.d(TAG, "Processando batch de ${articles.size} artigos")
                if (articles.size <= MAX_ARTICLES_PER_BATCH) {
                    processSingleBatch(articles)
                } else {
                    Log.d(TAG, "Dividindo em m√∫ltiplos batches")
                    articles.chunked(MAX_ARTICLES_PER_BATCH).flatMap { batch ->
                        processSingleBatch(batch)
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Erro ao processar batch: ${e.message}", e)
                articles
            }
        }
    }
    
    private suspend fun processSingleBatch(articles: List<NewsArticle>): List<NewsArticle> {
        return try {
            Log.d(TAG, "Processando batch √∫nico com ${articles.size} artigos")
            
            val prompt = buildBatchPrompt(articles) // 52 lines of nested append()
            val request = GeminiRequest(
                contents = listOf(
                    GeminiContent(parts = listOf(GeminiPart(text = prompt)))
                )
            )
            
            val response = geminiService.generateContent(ApiKeys.GEMINI_API_KEY, request)
            val responseText = response.candidates.firstOrNull()
                ?.content?.parts?.firstOrNull()?.text?.trim()
            
            if (responseText.isNullOrBlank()) {
                Log.w(TAG, "Resposta vazia do Gemini para batch")
                return articles
            }
            
            Log.d(TAG, "Resposta do Gemini recebida, fazendo parse...")
            val parsedArticles = parseBatchResponse(responseText, articles) // Complex nested parsing
            Log.d(TAG, "Batch processado com sucesso: ${parsedArticles.size} artigos")
            
            parsedArticles
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao processar batch √∫nico: ${e.message}", e)
            articles
        }
    }
    
    // 52 lines of nested append() with complex logic...
    private fun buildBatchPrompt(articles: List<NewsArticle>): String { /* ... */ }
    
    // 40+ lines of nested parsing logic...
    private fun parseBatchResponse(response: String, originalArticles: List<NewsArticle>): List<NewsArticle> { /* ... */ }
}
```

**Problems**:
- ‚ùå Functions too long (52 lines, 40+ lines)
- ‚ùå Deep nesting (4 levels)
- ‚ùå Multiple responsibilities per function
- ‚ùå Excessive logging
- ‚ùå Hard to read and maintain
- ‚ùå Difficult to test individual parts

### After (Simple - 183 lines, clear structure, single responsibilities)

```kotlin
class ProcessBatchArticlesUseCase(private val geminiService: GeminiService) {
    
    companion object {
        private const val MAX_ARTICLES_PER_BATCH = 5
        private const val MAX_CONTENT_LENGTH = 1000
        private const val MAX_DESCRIPTION_LENGTH = 300
    }
    
    // Main entry point - clear and concise
    suspend operator fun invoke(articles: List<NewsArticle>): List<NewsArticle> {
        return withContext(Dispatchers.IO) {
            try {
                if (articles.size <= MAX_ARTICLES_PER_BATCH) {
                    processArticles(articles)
                } else {
                    processBatches(articles)
                }
            } catch (e: Exception) {
                articles
            }
        }
    }
    
    // Single responsibility: divide into batches
    private suspend fun processBatches(articles: List<NewsArticle>): List<NewsArticle> {
        return articles.chunked(MAX_ARTICLES_PER_BATCH).flatMap { batch ->
            processArticles(batch)
        }
    }
    
    // Single responsibility: process a list of articles
    private suspend fun processArticles(articles: List<NewsArticle>): List<NewsArticle> {
        return try {
            val response = callGeminiApi(articles)
            parseResponse(response, articles)
        } catch (e: Exception) {
            articles
        }
    }
    
    // Single responsibility: call Gemini API
    private suspend fun callGeminiApi(articles: List<NewsArticle>): String? {
        val prompt = buildPrompt(articles)
        val request = buildGeminiRequest(prompt)
        val response = geminiService.generateContent(ApiKeys.GEMINI_API_KEY, request)
        return response.candidates.firstOrNull()?.content?.parts?.firstOrNull()?.text?.trim()
    }
    
    // Single responsibility: build request object
    private fun buildGeminiRequest(prompt: String): GeminiRequest {
        return GeminiRequest(
            contents = listOf(
                GeminiContent(parts = listOf(GeminiPart(text = prompt)))
            )
        )
    }
    
    // Single responsibility: orchestrate prompt building
    private fun buildPrompt(articles: List<NewsArticle>): String {
        return buildString {
            appendInstructions(articles.size)
            appendArticles(articles)
            appendResponseFormat(articles.size)
        }
    }
    
    // Extension functions for clarity and reusability
    private fun StringBuilder.appendInstructions(articleCount: Int) {
        append("""
            Voc√™ √© um editor de not√≠cias experiente. 
            Receber√° $articleCount not√≠cias...
        """.trimIndent())
    }
    
    private fun StringBuilder.appendArticles(articles: List<NewsArticle>) {
        articles.forEachIndexed { index, article ->
            append("\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
            append("NOT√çCIA ${index + 1}\n")
            append("T√≠tulo: ${article.title}\n")
            
            article.description?.takeIf { it.isNotBlank() }?.let {
                append("Descri√ß√£o: ${truncate(it, MAX_DESCRIPTION_LENGTH)}\n")
            }
            
            article.content?.takeIf { it.isNotBlank() }?.let {
                append("Conte√∫do: ${truncate(it, MAX_CONTENT_LENGTH)}\n")
            }
        }
    }
    
    private fun StringBuilder.appendResponseFormat(articleCount: Int) {
        append("""
            
            === FORMATO DE RESPOSTA EXIGIDO ===
            ...
        """.trimIndent())
    }
    
    // Single responsibility: parse response
    private fun parseResponse(response: String?, originalArticles: List<NewsArticle>): List<NewsArticle> {
        if (response.isNullOrBlank()) return originalArticles
        
        return try {
            originalArticles.mapIndexed { index, article ->
                parseArticle(response, index + 1, article)
            }
        } catch (e: Exception) {
            originalArticles
        }
    }
    
    // Single responsibility: parse one article
    private fun parseArticle(response: String, articleNum: Int, original: NewsArticle): NewsArticle {
        val articleBlock = extractArticleBlock(response, articleNum) ?: return original
        
        return original.copy(
            title = extractTag(articleBlock, "TITLE") ?: original.title,
            description = extractTag(articleBlock, "DESCRIPTION") ?: original.description,
            content = extractTag(articleBlock, "SUMMARY") ?: original.content
        )
    }
    
    // Reusable utility functions with clear names
    private fun extractArticleBlock(response: String, articleNum: Int): String? {
        val pattern = """\[ARTICLE_$articleNum\](.*?)\[/ARTICLE_$articleNum\]"""
            .toRegex(RegexOption.DOT_MATCHES_ALL)
        return pattern.find(response)?.groupValues?.get(1)
    }
    
    private fun extractTag(text: String, tag: String): String? {
        val pattern = """\[$tag\](.*?)\[/$tag\]""".toRegex(RegexOption.DOT_MATCHES_ALL)
        return pattern.find(text)?.groupValues?.get(1)?.trim()
    }
    
    private fun truncate(text: String, maxLength: Int): String {
        return if (text.length <= maxLength) text else "${text.take(maxLength)}..."
    }
}
```

**Improvements**:
- ‚úÖ Small functions (3-15 lines each)
- ‚úÖ Single responsibility per function
- ‚úÖ Clear, descriptive names
- ‚úÖ Max 2 levels of nesting
- ‚úÖ No excessive logging
- ‚úÖ Easy to read and understand
- ‚úÖ Easy to test each function
- ‚úÖ Kotlin idioms (extension functions, safe calls, mapIndexed)
- ‚úÖ Reusable utility functions

**Key Takeaways**:
1. **Break it down**: One large function ‚Üí Many small functions
2. **Name well**: Function names explain what they do
3. **Single purpose**: Each function does one thing
4. **Less nesting**: Early returns and guard clauses
5. **No logs**: Silent error handling with fallbacks
6. **Kotlin style**: Use language features (extensions, safe calls, functional operators)
